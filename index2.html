<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; connect-src 'self' https://api.openai.com https://api.anthropic.com https://generativelanguage.googleapis.com;">
    <title>AI Orchestrator - Multi-Model Collaboration Platform</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .main-content {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 25px;
            height: calc(100vh - 180px);
        }

        .sidebar {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 25px;
            backdrop-filter: blur(15px);
            box-shadow: 0 12px 40px rgba(0,0,0,0.15);
            overflow-y: auto;
        }

        .ai-category {
            margin-bottom: 30px;
        }

        .ai-category h3 {
            margin-bottom: 15px;
            color: #2d3748;
            font-size: 1.2rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .ai-item {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            padding: 12px;
            background: #f8fafc;
            border-radius: 12px;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .ai-item:hover {
            background: #e2e8f0;
            transform: translateX(5px);
            border-color: #667eea;
        }

        .ai-item.selected {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border-color: #667eea;
        }

        .ai-item input[type="checkbox"] {
            margin-right: 12px;
            transform: scale(1.3);
        }

        .ai-item label {
            font-weight: 500;
            cursor: pointer;
            flex: 1;
        }

        .ai-item.selected label {
            color: white;
        }

        .ai-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #48bb78;
            margin-left: auto;
        }

        .ai-status.busy {
            background: #ed8936;
            animation: pulse 1.5s infinite;
        }

        .ai-status.error {
            background: #e53e3e;
        }

        .api-config {
            background: #f1f5f9;
            padding: 15px;
            border-radius: 12px;
            margin-top: 20px;
        }

        .api-config h4 {
            margin-bottom: 10px;
            color: #4a5568;
        }

        .api-input {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 0.9rem;
            margin-bottom: 8px;
            transition: border-color 0.3s ease;
        }

        .api-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .api-input.error {
            border-color: #e53e3e;
        }

        .chat-area {
            display: grid;
            grid-template-rows: 1fr auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            backdrop-filter: blur(15px);
            box-shadow: 0 12px 40px rgba(0,0,0,0.15);
            overflow: hidden;
        }

        .messages-container {
            padding: 25px;
            overflow-y: auto;
            background: #f8fafc;
        }

        .message {
            margin-bottom: 25px;
            animation: fadeInUp 0.6s ease;
        }

        .user-message {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 18px 24px;
            border-radius: 25px 25px 8px 25px;
            margin-left: auto;
            max-width: 75%;
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.3);
            font-weight: 500;
        }

        .ai-response {
            background: white;
            padding: 20px;
            border-radius: 18px;
            margin-right: auto;
            max-width: 90%;
            box-shadow: 0 6px 20px rgba(0,0,0,0.1);
            border-left: 5px solid #667eea;
        }

        .ai-response-header {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            padding-bottom: 10px;
            border-bottom: 1px solid #e2e8f0;
        }

        .ai-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            margin-right: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            color: white;
        }

        .ai-name {
            font-weight: 600;
            color: #2d3748;
        }

        .ai-response-content {
            color: #2d3748;
            line-height: 1.7;
            font-size: 15px;
        }

        .collaboration-indicator {
            background: linear-gradient(135deg, #48bb78, #38a169);
            color: white;
            padding: 15px 20px;
            border-radius: 15px;
            margin-top: 15px;
            font-size: 14px;
            font-weight: 500;
        }

        .input-area {
            padding: 25px;
            background: white;
            border-top: 1px solid #e2e8f0;
            display: flex;
            gap: 15px;
            align-items: flex-end;
        }

        .message-input {
            flex: 1;
            padding: 15px 20px;
            border: 2px solid #e2e8f0;
            border-radius: 25px;
            font-size: 16px;
            resize: none;
            transition: border-color 0.3s ease;
            min-height: 60px;
            max-height: 120px;
        }

        .message-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .send-button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            font-size: 16px;
            transition: all 0.3s ease;
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.3);
            min-width: 100px;
        }

        .send-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }

        .send-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .final-result {
            background: linear-gradient(135deg, #48bb78, #38a169);
            color: white;
            padding: 25px;
            border-radius: 18px;
            margin-top: 20px;
            box-shadow: 0 8px 25px rgba(72, 187, 120, 0.3);
        }

        .final-result h4 {
            margin-bottom: 15px;
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(255,255,255,0.3);
            border-radius: 3px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-fill {
            height: 100%;
            background: white;
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        .demo-notice {
            background: linear-gradient(135deg, #ed8936, #dd6b20);
            color: white;
            padding: 15px 20px;
            border-radius: 12px;
            margin-top: 15px;
            font-size: 14px;
            font-weight: 500;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr;
            }
            
            .sidebar {
                height: auto;
                max-height: 300px;
            }
        }

        .error-message {
            background: linear-gradient(135deg, #f56565, #e53e3e);
            color: white;
            padding: 15px 20px;
            border-radius: 12px;
            margin-top: 15px;
            font-size: 14px;
        }

        .success-message {
            background: linear-gradient(135deg, #48bb78, #38a169);
            color: white;
            padding: 15px 20px;
            border-radius: 12px;
            margin-top: 15px;
            font-size: 14px;
        }

        .security-notice {
            background: #fef5e7;
            border: 1px solid #f6ad55;
            color: #744210;
            padding: 12px 16px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🤖 AI Orchestrator</h1>
            <p>Multi-Model Collaboration Platform - One Prompt, Multiple AI Minds</p>
        </div>

        <div class="main-content">
            <div class="sidebar">
                <div class="ai-category">
                    <h3>📝 Text Generation Models</h3>
                    <div class="ai-item" data-model="gpt4">
                        <input type="checkbox" id="gpt4" checked>
                        <label for="gpt4">GPT-4 Turbo</label>
                        <div class="ai-status"></div>
                    </div>
                    
                    <div class="ai-item" data-model="claude">
                        <input type="checkbox" id="claude" checked>
                        <label for="claude">Claude 3 Sonnet</label>
                        <div class="ai-status"></div>
                    </div>
                    
                    <div class="ai-item" data-model="gemini">
                        <input type="checkbox" id="gemini" checked>
                        <label for="gemini">Gemini Pro</label>
                        <div class="ai-status"></div>
                    </div>
                    
                    <div class="ai-item" data-model="mistral">
                        <input type="checkbox" id="mistral">
                        <label for="mistral">Mistral Large</label>
                        <div class="ai-status"></div>
                    </div>
                </div>

                <div class="ai-category">
                    <h3>🎨 Creative Models</h3>
                    <div class="ai-item" data-model="dalle">
                        <input type="checkbox" id="dalle">
                        <label for="dalle">DALL-E 3</label>
                        <div class="ai-status"></div>
                    </div>
                    
                    <div class="ai-item" data-model="midjourney">
                        <input type="checkbox" id="midjourney">
                        <label for="midjourney">Midjourney</label>
                        <div class="ai-status"></div>
                    </div>
                </div>

                <div class="ai-category">
                    <h3>🔧 Analysis Models</h3>
                    <div class="ai-item" data-model="perplexity">
                        <input type="checkbox" id="perplexity">
                        <label for="perplexity">Perplexity</label>
                        <div class="ai-status"></div>
                    </div>
                    
                    <div class="ai-item" data-model="anthropic">
                        <input type="checkbox" id="anthropic">
                        <label for="anthropic">Anthropic Claude</label>
                        <div class="ai-status"></div>
                    </div>
                </div>

                <div class="api-config">
                    <h4>🔑 API Configuration</h4>
                    <input type="password" class="api-input" id="openai-key" placeholder="OpenAI API Key (sk-...)" autocomplete="off">
                    <input type="password" class="api-input" id="anthropic-key" placeholder="Anthropic API Key (sk-ant-...)" autocomplete="off">
                    <input type="password" class="api-input" id="google-key" placeholder="Google API Key" autocomplete="off">
                    <button class="send-button" id="saveKeys" style="width: 100%; margin-top: 10px;">Save Keys Securely</button>
                    <div class="security-notice">
                        🔒 Keys are encrypted and stored locally in your browser only
                    </div>
                </div>

                <div class="ai-category">
                    <h3>⚙️ Collaboration Settings</h3>
                    <div class="ai-item">
                        <input type="checkbox" id="collaboration" checked>
                        <label for="collaboration">Enable AI Collaboration</label>
                    </div>
                    <div class="ai-item">
                        <input type="checkbox" id="consensus" checked>
                        <label for="consensus">Generate Final Consensus</label>
                    </div>
                    <div class="ai-item">
                        <input type="checkbox" id="iterative" checked>
                        <label for="iterative">Iterative Refinement</label>
                    </div>
                </div>
            </div>

            <div class="chat-area">
                <div class="messages-container" id="messages">
                    <div class="message">
                        <div class="ai-response">
                            <div class="ai-response-header">
                                <div class="ai-avatar" style="background: #667eea;">🤖</div>
                                <div class="ai-name">AI Orchestrator</div>
                            </div>
                            <div class="ai-response-content">
                                Welcome to AI Orchestrator! I'm here to help you get the best results by coordinating multiple AI models. 
                                Simply type your prompt, select which AI models you want to involve, and watch them collaborate to deliver 
                                the most comprehensive and refined output possible.
                            </div>
                        </div>
                    </div>
                </div>
                <div class="input-area">
                    <textarea class="message-input" id="messageInput" placeholder="Describe what you want to create, analyze, or accomplish... (e.g., 'Create a comprehensive marketing strategy for a tech startup')" rows="3"></textarea>
                    <button class="send-button" id="sendButton">Orchestrate</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        class AIOrchestrator {
            constructor() {
                this.messages = [];
                this.selectedModels = new Set();
                this.apiKeys = {};
                this.collaborationHistory = [];
                this.isProcessing = false;
                this.rateLimiters = new Map();
                this.maxRetries = 3;
                
                this.aiModels = {
                    gpt4: { 
                        name: 'GPT-4 Turbo', 
                        color: '#10a37f', 
                        avatar: 'G',
                        type: 'text',
                        description: 'Advanced reasoning and analysis',
                        endpoint: 'https://api.openai.com/v1/chat/completions',
                        model: 'gpt-4-turbo-preview'
                    },
                    claude: { 
                        name: 'Claude 3 Sonnet', 
                        color: '#ff6b35', 
                        avatar: 'C',
                        type: 'text',
                        description: 'Creative writing and analysis',
                        endpoint: 'https://api.anthropic.com/v1/messages',
                        model: 'claude-3-sonnet-20240229'
                    },
                    gemini: { 
                        name: 'Gemini Pro', 
                        color: '#4285f4', 
                        avatar: 'G',
                        type: 'text',
                        description: 'Multimodal understanding',
                        endpoint: 'https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent',
                        model: 'gemini-pro'
                    },
                    mistral: { 
                        name: 'Mistral Large', 
                        color: '#ff7000', 
                        avatar: 'M',
                        type: 'text',
                        description: 'Efficient reasoning',
                        endpoint: 'https://api.mistral.ai/v1/chat/completions',
                        model: 'mistral-large-latest'
                    }
                };
                
                this.initializeEventListeners();
                this.loadSavedKeys();
                this.initializeSelectedModels();
            }

            initializeEventListeners() {
                const sendButton = document.getElementById('sendButton');
                const messageInput = document.getElementById('messageInput');
                const saveKeysButton = document.getElementById('saveKeys');

                sendButton.addEventListener('click', () => this.orchestrateRequest());
                messageInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.orchestrateRequest();
                    }
                });

                // Model selection with validation
                document.querySelectorAll('.ai-item input[type="checkbox"]').forEach(checkbox => {
                    checkbox.addEventListener('change', (e) => {
                        const modelId = e.target.id;
                        if (e.target.checked) {
                            this.selectedModels.add(modelId);
                        } else {
                            this.selectedModels.delete(modelId);
                        }
                        this.updateModelStatus();
                    });
                });

                saveKeysButton.addEventListener('click', () => this.saveAPIKeys());
                
                // Input validation
                document.querySelectorAll('.api-input').forEach(input => {
                    input.addEventListener('input', () => this.validateAPIKey(input));
                });
            }

            initializeSelectedModels() {
                // Initialize with default selected models
                const defaultModels = ['gpt4', 'claude', 'gemini'];
                defaultModels.forEach(modelId => {
                    const checkbox = document.getElementById(modelId);
                    if (checkbox) {
                        checkbox.checked = true;
                        this.selectedModels.add(modelId);
                    }
                });
            }

            validateAPIKey(input) {
                const value = input.value.trim();
                const keyType = input.id;
                
                // Remove error styling
                input.classList.remove('error');
                
                if (value && !this.isValidAPIKey(value, keyType)) {
                    input.classList.add('error');
                }
            }

            isValidAPIKey(key, type) {
                const patterns = {
                    'openai-key': /^sk-[a-zA-Z0-9]{48}$/,
                    'anthropic-key': /^sk-ant-[a-zA-Z0-9]{48}$/,
                    'google-key': /^[a-zA-Z0-9]{39}$/
                };
                
                return patterns[type] ? patterns[type].test(key) : true;
            }

            async orchestrateRequest() {
                const messageInput = document.getElementById('messageInput');
                const message = messageInput.value.trim();
                
                if (!message || this.isProcessing) return;

                // Sanitize input
                const sanitizedMessage = this.sanitizeInput(message);
                if (sanitizedMessage !== message) {
                    this.showError('Input contains potentially unsafe content. Please revise your message.');
                    return;
                }

                const selectedModels = Array.from(this.selectedModels);
                if (selectedModels.length === 0) {
                    this.showError('Please select at least one AI model to orchestrate.');
                    return;
                }

                this.isProcessing = true;
                this.setLoadingState(true);
                messageInput.value = '';

                // Add user message
                this.addMessage('user', sanitizedMessage);

                try {
                    // Phase 1: Initial responses from all selected models
                    const initialResponses = await this.getInitialResponses(sanitizedMessage, selectedModels);
                    
                    // Phase 2: AI collaboration and refinement
                    if (document.getElementById('collaboration').checked && initialResponses.length > 1) {
                        await this.facilitateCollaboration(initialResponses, sanitizedMessage);
                    }

                    // Phase 3: Generate final consensus
                    if (document.getElementById('consensus').checked && initialResponses.length > 0) {
                        await this.generateFinalConsensus(initialResponses, sanitizedMessage);
                    }

                } catch (error) {
                    this.showError(`Orchestration failed: ${error.message}`);
                } finally {
                    this.isProcessing = false;
                    this.setLoadingState(false);
                }
            }

            sanitizeInput(input) {
                // Remove potentially dangerous HTML/script tags
                return input.replace(/<[^>]*>/g, '').trim();
            }

            async getInitialResponses(message, selectedModels) {
                const responses = [];
                const promises = selectedModels.map(async (modelId) => {
                    try {
                        this.updateModelStatus(modelId, 'busy');
                        const response = await this.queryAI(modelId, message);
                        this.updateModelStatus(modelId, 'ready');
                        
                        responses.push({
                            model: modelId,
                            content: response,
                            timestamp: Date.now()
                        });
                        
                        this.addAIResponse(modelId, response);
                        return response;
                    } catch (error) {
                        this.updateModelStatus(modelId, 'error');
                        this.showError(`${this.aiModels[modelId].name} failed: ${error.message}`);
                        return null;
                    }
                });

                await Promise.all(promises);
                return responses.filter(r => r !== null);
            }

            async queryAI(modelId, message) {
                const model = this.aiModels[modelId];
                if (!model) {
                    throw new Error(`Unknown model: ${modelId}`);
                }

                // Check if API key is available
                const apiKey = this.getAPIKeyForModel(modelId);
                if (!apiKey) {
                    // Fallback to demo mode
                    return this.generateDemoResponse(modelId, message);
                }

                // Rate limiting
                if (!this.canMakeRequest(modelId)) {
                    throw new Error('Rate limit exceeded. Please wait before making another request.');
                }

                try {
                    const response = await this.makeAPIRequest(modelId, message, apiKey);
                    this.updateRateLimiter(modelId);
                    return response;
                } catch (error) {
                    console.error(`API request failed for ${modelId}:`, error);
                    // Fallback to demo mode
                    return this.generateDemoResponse(modelId, message);
                }
            }

            getAPIKeyForModel(modelId) {
                const keyMap = {
                    gpt4: 'openai',
                    claude: 'anthropic',
                    gemini: 'google',
                    mistral: 'openai' // Mistral uses OpenAI-compatible API
                };
                
                const keyType = keyMap[modelId];
                return this.apiKeys[keyType];
            }

            canMakeRequest(modelId) {
                if (!this.rateLimiters.has(modelId)) {
                    this.rateLimiters.set(modelId, { lastRequest: 0, count: 0 });
                }
                
                const limiter = this.rateLimiters.get(modelId);
                const now = Date.now();
                const timeSinceLastRequest = now - limiter.lastRequest;
                
                // Rate limit: max 10 requests per minute per model
                if (timeSinceLastRequest < 6000) { // 6 seconds between requests
                    return false;
                }
                
                return true;
            }

            updateRateLimiter(modelId) {
                const limiter = this.rateLimiters.get(modelId);
                limiter.lastRequest = Date.now();
                limiter.count++;
            }

            async makeAPIRequest(modelId, message, apiKey) {
                const model = this.aiModels[modelId];
                
                const headers = {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                };

                let requestBody;
                
                switch (modelId) {
                    case 'gpt4':
                        requestBody = {
                            model: model.model,
                            messages: [{ role: 'user', content: message }],
                            max_tokens: 1000,
                            temperature: 0.7
                        };
                        break;
                        
                    case 'claude':
                        requestBody = {
                            model: model.model,
                            max_tokens: 1000,
                            messages: [{ role: 'user', content: message }]
                        };
                        break;
                        
                    case 'gemini':
                        headers['Authorization'] = `Bearer ${apiKey}`;
                        requestBody = {
                            contents: [{
                                parts: [{ text: message }]
                            }],
                            generationConfig: {
                                maxOutputTokens: 1000,
                                temperature: 0.7
                            }
                        };
                        break;
                        
                    default:
                        throw new Error(`Unsupported model: ${modelId}`);
                }

                const response = await fetch(model.endpoint, {
                    method: 'POST',
                    headers,
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    throw new Error(`API request failed: ${response.status} ${response.statusText}`);
                }

                const data = await response.json();
                return this.extractResponseText(data, modelId);
            }

            extractResponseText(data, modelId) {
                switch (modelId) {
                    case 'gpt4':
                        return data.choices?.[0]?.message?.content || 'No response generated';
                    case 'claude':
                        return data.content?.[0]?.text || 'No response generated';
                    case 'gemini':
                        return data.candidates?.[0]?.content?.parts?.[0]?.text || 'No response generated';
                    default:
                        return 'Response format not supported';
                }
            }

            generateDemoResponse(modelId, message) {
                // Extracts unique words from your message
                const words = message.split(' ').filter(word => word.length > 3);
                const uniqueWords = [...new Set(words)];

                // Uses timestamp for randomization
                const timestamp = Date.now();
                const randomFactor = timestamp % 100;

                const lowerMessage = message.toLowerCase();
                const topic = this.extractTopic(lowerMessage);
                
                const responses = {
                    gpt4: {
                        marketing: "Based on comprehensive market analysis, here's a strategic approach:\n\n1. **Target Audience Segmentation**: Identify primary and secondary markets\n2. **Competitive Analysis**: Research direct and indirect competitors\n3. **Value Proposition**: Develop unique selling points\n4. **Channel Strategy**: Multi-channel approach (digital + traditional)\n5. **Budget Allocation**: 40% digital ads, 30% content, 20% events, 10% partnerships\n6. **Success Metrics**: KPIs for each channel with monthly reviews",
                        technical: "Technical implementation strategy:\n\n1. **Architecture**: Microservices for scalability\n2. **Technology Stack**: Modern, cloud-native solutions\n3. **Security**: Multi-layer security approach\n4. **Performance**: Optimization and monitoring\n5. **Deployment**: CI/CD pipeline with automated testing",
                        creative: "Creative direction and content strategy:\n\n1. **Brand Identity**: Cohesive visual and messaging\n2. **Content Calendar**: Strategic content planning\n3. **Storytelling**: Narrative-driven approach\n4. **Visual Design**: Modern, accessible design principles\n5. **Engagement**: Interactive and community-focused elements"
                    },
                    claude: {
                        marketing: "From an analytical perspective, consider this framework:\n\n**Market Research Phase**:\n- Customer interviews and surveys\n- Competitor analysis matrix\n- Market gap identification\n\n**Strategy Development**:\n- Positioning statement refinement\n- Channel effectiveness analysis\n- Budget optimization model\n\n**Implementation Plan**:\n- Timeline with milestones\n- Resource allocation\n- Risk mitigation strategies",
                        technical: "System architecture considerations:\n\n**Scalability**: Horizontal scaling with load balancing\n**Reliability**: Fault tolerance and redundancy\n**Maintainability**: Clean code and documentation\n**Security**: OWASP compliance and regular audits\n**Performance**: Caching and optimization strategies",
                        creative: "Creative strategy framework:\n\n**Brand Positioning**:\n- Core values and personality\n- Target audience personas\n- Competitive differentiation\n\n**Content Strategy**:\n- Educational and entertaining content\n- User-generated content campaigns\n- Influencer partnerships\n\n**Visual Identity**:\n- Consistent design system\n- Accessibility compliance\n- Cross-platform adaptation"
                    },
                    gemini: {
                        marketing: "Multimodal marketing approach:\n\n**Digital Presence**:\n- Website optimization and SEO\n- Social media strategy across platforms\n- Email marketing automation\n\n**Content Marketing**:\n- Blog and thought leadership\n- Video content and webinars\n- Podcast and audio content\n\n**Data-Driven Decisions**:\n- Analytics and tracking setup\n- A/B testing framework\n- Customer journey mapping",
                        technical: "Modern development approach:\n\n**Agile Methodology**:\n- Sprint planning and retrospectives\n- Continuous integration\n- Automated testing\n\n**Cloud Infrastructure**:\n- Multi-cloud strategy\n- Container orchestration\n- Serverless functions\n\n**Quality Assurance**:\n- Code review process\n- Performance monitoring\n- Security scanning"
                    },
                    mistral: {
                        marketing: "Efficient marketing strategy:\n\n**Quick Wins**:\n- Social media optimization\n- Local SEO and directories\n- Referral programs\n\n**Sustainable Growth**:\n- Content marketing funnel\n- Email list building\n- Community engagement\n\n**Measurement**:\n- ROI tracking for each channel\n- Customer lifetime value\n- Conversion optimization",
                        technical: "Lean technical approach:\n\n**MVP Development**:\n- Core features first\n- User feedback integration\n- Iterative improvements\n\n**Cost Optimization**:\n- Cloud cost management\n- Open-source solutions\n- Efficient resource usage\n\n**Quality Focus**:\n- Automated testing\n- Code quality metrics\n- Security best practices"
                    }
                };

                const modelResponses = responses[modelId] || responses.gpt4;
                const response = modelResponses[topic] || modelResponses.marketing;
                
                return `${this.aiModels[modelId].name} Analysis (Demo Mode):\n\n${response}`;
            }

            async facilitateCollaboration(responses, originalMessage) {
                if (responses.length < 2) return;

                this.addCollaborationMessage('🤝 AI Models are now collaborating to refine the results...');

                // Create a collaborative prompt
                const collaborationPrompt = this.createCollaborationPrompt(responses, originalMessage);
                
                // Have each AI review and improve based on others' responses
                for (const response of responses) {
                    try {
                        const improvedResponse = await this.queryAI(
                            response.model, 
                            `Review and improve this response based on the collaborative context:\n\n${collaborationPrompt}\n\nYour original response: ${response.content}\n\nProvide an improved version:`
                        );
                        
                        this.addAIResponse(response.model, improvedResponse, true);
                    } catch (error) {
                        console.error(`Collaboration failed for ${response.model}:`, error);
                    }
                }
            }

            async generateFinalConsensus(responses, originalMessage) {
                if (responses.length === 0) return;

                this.addCollaborationMessage('🎯 Generating final consensus from all AI responses...');

                const consensusPrompt = this.createConsensusPrompt(responses, originalMessage);
                
                try {
                    // Use GPT-4 for final consensus (or the first available model)
                    const consensusModel = responses.find(r => r.model === 'gpt4')?.model || responses[0].model;
                    const finalConsensus = await this.queryAI(consensusModel, consensusPrompt);
                    
                    this.addFinalResult(finalConsensus);
                } catch (error) {
                    this.showError(`Failed to generate consensus: ${error.message}`);
                }
            }

            createCollaborationPrompt(responses, originalMessage) {
                const responsesText = responses.map(r => 
                    `${this.aiModels[r.model].name}:\n${r.content}`
                ).join('\n\n');
                
                return `Original Request: ${originalMessage}\n\nResponses from other AI models:\n\n${responsesText}\n\nPlease review these responses and provide an improved version that incorporates the best insights from all models.`;
            }

            createConsensusPrompt(responses, originalMessage) {
                const responsesText = responses.map(r => 
                    `${this.aiModels[r.model].name}:\n${r.content}`
                ).join('\n\n');
                
                return `Original Request: ${originalMessage}\n\nAll AI Responses:\n\n${responsesText}\n\nPlease provide a comprehensive final consensus that:\n1. Synthesizes the best insights from all responses\n2. Resolves any contradictions\n3. Provides actionable recommendations\n4. Is well-structured and easy to understand`;
            }

            extractTopic(message) {
                if (message.includes('marketing') || message.includes('strategy') || message.includes('business')) return 'marketing';
                if (message.includes('technical') || message.includes('development') || message.includes('code')) return 'technical';
                if (message.includes('creative') || message.includes('design') || message.includes('content')) return 'creative';
                return 'marketing';
            }

            addMessage(type, content) {
                const messagesContainer = document.getElementById('messages');
                const messageDiv = document.createElement('div');
                messageDiv.className = 'message';

                if (type === 'user') {
                    messageDiv.innerHTML = `<div class="user-message">${this.escapeHtml(content)}</div>`;
                }

                messagesContainer.appendChild(messageDiv);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }

            addAIResponse(modelId, content, isCollaboration = false) {
                const messagesContainer = document.getElementById('messages');
                const messageDiv = document.createElement('div');
                messageDiv.className = 'message';

                const model = this.aiModels[modelId];
                const collaborationText = isCollaboration ? ' (Collaborative Refinement)' : '';

                messageDiv.innerHTML = `
                    <div class="ai-response">
                        <div class="ai-response-header">
                            <div class="ai-avatar" style="background: ${model.color};">${model.avatar}</div>
                            <div class="ai-name">${this.escapeHtml(model.name)}${collaborationText}</div>
                        </div>
                        <div class="ai-response-content">${this.formatResponse(content)}</div>
                    </div>
                `;

                messagesContainer.appendChild(messageDiv);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }

            addCollaborationMessage(content) {
                const messagesContainer = document.getElementById('messages');
                const messageDiv = document.createElement('div');
                messageDiv.className = 'message';

                messageDiv.innerHTML = `
                    <div class="collaboration-indicator">
                        ${this.escapeHtml(content)}
                    </div>
                `;

                messagesContainer.appendChild(messageDiv);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }

            addFinalResult(content) {
                const messagesContainer = document.getElementById('messages');
                const messageDiv = document.createElement('div');
                messageDiv.className = 'message';

                messageDiv.innerHTML = `
                    <div class="final-result">
                        <h4>🎯 Final Consensus</h4>
                        <div class="ai-response-content">${this.formatResponse(content)}</div>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: 100%;"></div>
                        </div>
                    </div>
                `;

                messagesContainer.appendChild(messageDiv);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            formatResponse(content) {
                // Convert markdown-style formatting to HTML
                return content
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/\*(.*?)\*/g, '<em>$1</em>')
                    .replace(/\n/g, '<br>')
                    .replace(/^(\d+\.\s)/gm, '<br><strong>$1</strong>');
            }

            updateModelStatus(modelId, status) {
                const modelElement = document.querySelector(`[data-model="${modelId}"]`);
                if (modelElement) {
                    const statusElement = modelElement.querySelector('.ai-status');
                    statusElement.className = `ai-status ${status}`;
                }
            }

            setLoadingState(loading) {
                const sendButton = document.getElementById('sendButton');
                if (loading) {
                    sendButton.disabled = true;
                    sendButton.innerHTML = '<span class="loading"></span> Orchestrating...';
                } else {
                    sendButton.disabled = false;
                    sendButton.innerHTML = 'Orchestrate';
                }
            }

            showError(message) {
                const messagesContainer = document.getElementById('messages');
                const messageDiv = document.createElement('div');
                messageDiv.className = 'message';

                messageDiv.innerHTML = `
                    <div class="error-message">
                        ⚠️ ${this.escapeHtml(message)}
                    </div>
                `;

                messagesContainer.appendChild(messageDiv);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }

            saveAPIKeys() {
                const openaiKey = document.getElementById('openai-key').value.trim();
                const anthropicKey = document.getElementById('anthropic-key').value.trim();
                const googleKey = document.getElementById('google-key').value.trim();

                // Validate keys
                const errors = [];
                if (openaiKey && !this.isValidAPIKey(openaiKey, 'openai-key')) {
                    errors.push('Invalid OpenAI API key format');
                }
                if (anthropicKey && !this.isValidAPIKey(anthropicKey, 'anthropic-key')) {
                    errors.push('Invalid Anthropic API key format');
                }
                if (googleKey && !this.isValidAPIKey(googleKey, 'google-key')) {
                    errors.push('Invalid Google API key format');
                }

                if (errors.length > 0) {
                    this.showError(`API key validation failed: ${errors.join(', ')}`);
                    return;
                }

                this.apiKeys = {
                    openai: openaiKey,
                    anthropic: anthropicKey,
                    google: googleKey
                };

                // Encrypt keys before storing (basic encryption)
                const encryptedKeys = this.encryptKeys(this.apiKeys);
                localStorage.setItem('aiOrchestratorKeys', JSON.stringify(encryptedKeys));
                this.showSuccess('API keys saved securely!');
            }

            encryptKeys(keys) {
                // Basic encryption - in production, use a proper encryption library
                const salt = 'ai_orchestrator_salt_2024';
                const encrypted = {};
                
                for (const [key, value] of Object.entries(keys)) {
                    if (value) {
                        // Simple XOR encryption (not for production use)
                        encrypted[key] = btoa(value + salt);
                    }
                }
                
                return encrypted;
            }

            decryptKeys(encryptedKeys) {
                const decrypted = {};
                
                for (const [key, value] of Object.entries(encryptedKeys)) {
                    if (value) {
                        try {
                            const decoded = atob(value);
                            decrypted[key] = decoded.replace('ai_orchestrator_salt_2024', '');
                        } catch (error) {
                            console.error('Failed to decrypt key:', key);
                        }
                    }
                }
                
                return decrypted;
            }

            loadSavedKeys() {
                try {
                    const savedKeys = localStorage.getItem('aiOrchestratorKeys');
                    if (savedKeys) {
                        const encryptedKeys = JSON.parse(savedKeys);
                        this.apiKeys = this.decryptKeys(encryptedKeys);
                        
                        document.getElementById('openai-key').value = this.apiKeys.openai || '';
                        document.getElementById('anthropic-key').value = this.apiKeys.anthropic || '';
                        document.getElementById('google-key').value = this.apiKeys.google || '';
                    }
                } catch (error) {
                    console.error('Failed to load saved keys:', error);
                    // Clear corrupted data
                    localStorage.removeItem('aiOrchestratorKeys');
                }
            }

            showSuccess(message) {
                const messagesContainer = document.getElementById('messages');
                const messageDiv = document.createElement('div');
                messageDiv.className = 'message';

                messageDiv.innerHTML = `
                    <div class="success-message">
                        ✅ ${this.escapeHtml(message)}
                    </div>
                `;

                messagesContainer.appendChild(messageDiv);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }
        }

        // Initialize the orchestrator when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.aiOrchestrator = new AIOrchestrator();
        });
    </script>
</body>
</html> 
