<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; connect-src 'self' https://api.openai.com https://api.anthropic.com https://generativelanguage.googleapis.com;">
    <title>AI Orchestrator - Multi-Model Collaboration Platform</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .main-content {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 25px;
            height: calc(100vh - 180px);
        }

        .sidebar {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 25px;
            backdrop-filter: blur(15px);
            box-shadow: 0 12px 40px rgba(0,0,0,0.15);
            overflow-y: auto;
        }

        .ai-category {
            margin-bottom: 30px;
        }

        .ai-category h3 {
            margin-bottom: 15px;
            color: #2d3748;
            font-size: 1.2rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .ai-item {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            padding: 12px;
            background: #f8fafc;
            border-radius: 12px;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .ai-item:hover {
            background: #e2e8f0;
            transform: translateX(5px);
            border-color: #667eea;
        }

        .ai-item.selected {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border-color: #667eea;
        }

        .ai-item input[type="checkbox"] {
            margin-right: 12px;
            transform: scale(1.3);
        }

        .ai-item label {
            font-weight: 500;
            cursor: pointer;
            flex: 1;
        }

        .ai-item.selected label {
            color: white;
        }

        .ai-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #48bb78;
            margin-left: auto;
        }

        .ai-status.busy {
            background: #ed8936;
            animation: pulse 1.5s infinite;
        }

        .ai-status.error {
            background: #e53e3e;
        }

        .api-config {
            background: #f1f5f9;
            padding: 15px;
            border-radius: 12px;
            margin-top: 20px;
        }

        .api-config h4 {
            margin-bottom: 10px;
            color: #4a5568;
        }

        .api-input {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 0.9rem;
            margin-bottom: 8px;
            transition: border-color 0.3s ease;
        }

        .api-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .api-input.error {
            border-color: #e53e3e;
        }

        .chat-area {
            display: grid;
            grid-template-rows: 1fr auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            backdrop-filter: blur(15px);
            box-shadow: 0 12px 40px rgba(0,0,0,0.15);
            overflow: hidden;
        }

        .messages-container {
            padding: 25px;
            overflow-y: auto;
            background: #f8fafc;
        }

        .message {
            margin-bottom: 25px;
            animation: fadeInUp 0.6s ease;
        }

        .user-message {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 18px 24px;
            border-radius: 25px 25px 8px 25px;
            margin-left: auto;
            max-width: 75%;
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.3);
            font-weight: 500;
        }

        .ai-response {
            background: white;
            padding: 20px;
            border-radius: 18px;
            margin-right: auto;
            max-width: 90%;
            box-shadow: 0 6px 20px rgba(0,0,0,0.1);
            border-left: 5px solid #667eea;
        }

        .ai-response-header {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            padding-bottom: 10px;
            border-bottom: 1px solid #e2e8f0;
        }

        .ai-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            margin-right: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            color: white;
        }

        .ai-name {
            font-weight: 600;
            color: #2d3748;
        }

        .ai-response-content {
            color: #2d3748;
            line-height: 1.7;
            font-size: 15px;
        }

        .collaboration-indicator {
            background: linear-gradient(135deg, #48bb78, #38a169);
            color: white;
            padding: 15px 20px;
            border-radius: 15px;
            margin-top: 15px;
            font-size: 14px;
            font-weight: 500;
        }

        .input-area {
            padding: 25px;
            background: white;
            border-top: 1px solid #e2e8f0;
            display: flex;
            gap: 15px;
            align-items: flex-end;
        }

        .message-input {
            flex: 1;
            padding: 15px 20px;
            border: 2px solid #e2e8f0;
            border-radius: 25px;
            font-size: 16px;
            resize: none;
            transition: border-color 0.3s ease;
            min-height: 60px;
            max-height: 120px;
        }

        .message-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .send-button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            font-size: 16px;
            transition: all 0.3s ease;
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.3);
            min-width: 100px;
        }

        .send-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }

        .send-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .final-result {
            background: linear-gradient(135deg, #48bb78, #38a169);
            color: white;
            padding: 25px;
            border-radius: 18px;
            margin-top: 20px;
            box-shadow: 0 8px 25px rgba(72, 187, 120, 0.3);
        }

        .final-result h4 {
            margin-bottom: 15px;
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(255,255,255,0.3);
            border-radius: 3px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-fill {
            height: 100%;
            background: white;
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        .demo-notice {
            background: linear-gradient(135deg, #ed8936, #dd6b20);
            color: white;
            padding: 15px 20px;
            border-radius: 12px;
            margin-top: 15px;
            font-size: 14px;
            font-weight: 500;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr;
            }
            
            .sidebar {
                height: auto;
                max-height: 300px;
            }
        }

        .error-message {
            background: linear-gradient(135deg, #f56565, #e53e3e);
            color: white;
            padding: 15px 20px;
            border-radius: 12px;
            margin-top: 15px;
            font-size: 14px;
        }

        .success-message {
            background: linear-gradient(135deg, #48bb78, #38a169);
            color: white;
            padding: 15px 20px;
            border-radius: 12px;
            margin-top: 15px;
            font-size: 14px;
        }

        .security-notice {
            background: #fef5e7;
            border: 1px solid #f6ad55;
            color: #744210;
            padding: 12px 16px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🤖 AI Orchestrator</h1>
            <p>Multi-Model Collaboration Platform - One Prompt, Multiple AI Minds</p>
        </div>

        <div class="main-content">
            <div class="sidebar">
                <div class="ai-category">
                    <h3>📝 Text Generation Models</h3>
                    <div class="ai-item" data-model="gpt4">
                        <input type="checkbox" id="gpt4" checked>
                        <label for="gpt4">GPT-4 Turbo</label>
                        <div class="ai-status"></div>
                    </div>
                    
                    <div class="ai-item" data-model="claude">
                        <input type="checkbox" id="claude" checked>
                        <label for="claude">Claude 3 Sonnet</label>
                        <div class="ai-status"></div>
                    </div>
                    
                    <div class="ai-item" data-model="gemini">
                        <input type="checkbox" id="gemini" checked>
                        <label for="gemini">Gemini Pro</label>
                        <div class="ai-status"></div>
                    </div>
                    
                    <div class="ai-item" data-model="mistral">
                        <input type="checkbox" id="mistral">
                        <label for="mistral">Mistral Large</label>
                        <div class="ai-status"></div>
                    </div>
                </div>

                <div class="ai-category">
                    <h3>🎨 Creative Models</h3>
                    <div class="ai-item" data-model="dalle">
                        <input type="checkbox" id="dalle">
                        <label for="dalle">DALL-E 3</label>
                        <div class="ai-status"></div>
                    </div>
                    
                    <div class="ai-item" data-model="midjourney">
                        <input type="checkbox" id="midjourney">
                        <label for="midjourney">Midjourney</label>
                        <div class="ai-status"></div>
                    </div>
                </div>

                <div class="ai-category">
                    <h3>🔧 Analysis Models</h3>
                    <div class="ai-item" data-model="perplexity">
                        <input type="checkbox" id="perplexity">
                        <label for="perplexity">Perplexity</label>
                        <div class="ai-status"></div>
                    </div>
                    
                    <div class="ai-item" data-model="anthropic">
                        <input type="checkbox" id="anthropic">
                        <label for="anthropic">Anthropic Claude</label>
                        <div class="ai-status"></div>
                    </div>
                </div>

                <div class="api-config">
                    <h4>🔑 API Configuration</h4>
                    <input type="password" class="api-input" id="openai-key" placeholder="OpenAI API Key (sk-...)" autocomplete="off">
                    <input type="password" class="api-input" id="anthropic-key" placeholder="Anthropic API Key (sk-ant-...)" autocomplete="off">
                    <input type="password" class="api-input" id="google-key" placeholder="Google API Key" autocomplete="off">
                    <button class="send-button" id="saveKeys" style="width: 100%; margin-top: 10px;">Save Keys Securely</button>
                    <div class="security-notice">
                        🔒 Keys are encrypted and stored locally in your browser only
                    </div>
                </div>

                <div class="ai-category">
                    <h3>⚙️ Collaboration Settings</h3>
                    <div class="ai-item">
                        <input type="checkbox" id="collaboration" checked>
                        <label for="collaboration">Enable AI Collaboration</label>
                    </div>
                    <div class="ai-item">
                        <input type="checkbox" id="consensus" checked>
                        <label for="consensus">Generate Final Consensus</label>
                    </div>
                    <div class="ai-item">
                        <input type="checkbox" id="iterative" checked>
                        <label for="iterative">Iterative Refinement</label>
                    </div>
                </div>
            </div>

            <div class="chat-area">
                <div class="messages-container" id="messages">
                    <div class="message">
                        <div class="ai-response">
                            <div class="ai-response-header">
                                <div class="ai-avatar" style="background: #667eea;">🤖</div>
                                <div class="ai-name">AI Orchestrator</div>
                            </div>
                            <div class="ai-response-content">
                                Welcome to AI Orchestrator! I'm here to help you get the best results by coordinating multiple AI models. 
                                Simply type your prompt, select which AI models you want to involve, and watch them collaborate to deliver 
                                the most comprehensive and refined output possible.
                            </div>
                        </div>
                    </div>
                </div>
                <div class="input-area">
                    <textarea class="message-input" id="messageInput" placeholder="Describe what you want to create, analyze, or accomplish... (e.g., 'Create a comprehensive marketing strategy for a tech startup')" rows="3"></textarea>
                    <button class="send-button" id="sendButton">Orchestrate</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        class AIOrchestrator {
            constructor() {
                this.messages = [];
                this.selectedModels = new Set();
                this.apiKeys = {};
                this.collaborationHistory = [];
                this.isProcessing = false;
                this.rateLimiters = new Map();
                this.maxRetries = 3;
                
                this.aiModels = {
                    gpt4: { 
                        name: 'GPT-4 Turbo', 
                        color: '#10a37f', 
                        avatar: 'G',
                        type: 'text',
                        description: 'Advanced reasoning and analysis',
                        endpoint: 'https://api.openai.com/v1/chat/completions',
                        model: 'gpt-4-turbo-preview'
                    },
                    claude: { 
                        name: 'Claude 3 Sonnet', 
                        color: '#ff6b35', 
                        avatar: 'C',
                        type: 'text',
                        description: 'Creative writing and analysis',
                        endpoint: 'https://api.anthropic.com/v1/messages',
                        model: 'claude-3-sonnet-20240229'
                    },
                    gemini: { 
                        name: 'Gemini Pro', 
                        color: '#4285f4', 
                        avatar: 'G',
                        type: 'text',
                        description: 'Multimodal understanding',
                        endpoint: 'https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent',
                        model: 'gemini-pro'
                    },
                    mistral: { 
                        name: 'Mistral Large', 
                        color: '#ff7000', 
                        avatar: 'M',
                        type: 'text',
                        description: 'Efficient reasoning',
                        endpoint: 'https://api.mistral.ai/v1/chat/completions',
                        model: 'mistral-large-latest'
                    }
                };
                
                this.initializeEventListeners();
                this.loadSavedKeys();
                this.initializeSelectedModels();
            }

            initializeEventListeners() {
                const sendButton = document.getElementById('sendButton');
                const messageInput = document.getElementById('messageInput');
                const saveKeysButton = document.getElementById('saveKeys');

                sendButton.addEventListener('click', () => this.orchestrateRequest());
                messageInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.orchestrateRequest();
                    }
                });

                // Model selection with validation
                document.querySelectorAll('.ai-item input[type="checkbox"]').forEach(checkbox => {
                    checkbox.addEventListener('change', (e) => {
                        const modelId = e.target.id;
                        if (e.target.checked) {
                            this.selectedModels.add(modelId);
                        } else {
                            this.selectedModels.delete(modelId);
                        }
                        this.updateModelStatus();
                    });
                });

                saveKeysButton.addEventListener('click', () => this.saveAPIKeys());
                
                // Input validation
                document.querySelectorAll('.api-input').forEach(input => {
                    input.addEventListener('input', () => this.validateAPIKey(input));
                });
            }

            initializeSelectedModels() {
                // Initialize with default selected models
                const defaultModels = ['gpt4', 'claude', 'gemini'];
                defaultModels.forEach(modelId => {
                    const checkbox = document.getElementById(modelId);
                    if (checkbox) {
                        checkbox.checked = true;
                        this.selectedModels.add(modelId);
                    }
                });
            }

            validateAPIKey(input) {
                const value = input.value.trim();
                const keyType = input.id;
                
                // Remove error styling
                input.classList.remove('error');
                
                if (value && !this.isValidAPIKey(value, keyType)) {
                    input.classList.add('error');
                }
            }

            isValidAPIKey(key, type) {
                const patterns = {
                    'openai-key': /^sk-[a-zA-Z0-9]{48}$/,
                    'anthropic-key': /^sk-ant-[a-zA-Z0-9]{48}$/,
                    'google-key': /^[a-zA-Z0-9]{39}$/
                };
                
                return patterns[type] ? patterns[type].test(key) : true;
            }

            async orchestrateRequest() {
                const messageInput = document.getElementById('messageInput');
                const message = messageInput.value.trim();
                
                if (!message || this.isProcessing) return;

                // Sanitize input
                const sanitizedMessage = this.sanitizeInput(message);
                if (sanitizedMessage !== message) {
                    this.showError('Input contains potentially unsafe content. Please revise your message.');
                    return;
                }

                const selectedModels = Array.from(this.selectedModels);
                if (selectedModels.length === 0) {
                    this.showError('Please select at least one AI model to orchestrate.');
                    return;
                }

                this.isProcessing = true;
                this.setLoadingState(true);
                messageInput.value = '';

                // Add user message
                this.addMessage('user', sanitizedMessage);

                try {
                    // Phase 1: Initial responses from all selected models
                    const initialResponses = await this.getInitialResponses(sanitizedMessage, selectedModels);
                    
                    // Phase 2: AI collaboration and refinement
                    if (document.getElementById('collaboration').checked && initialResponses.length > 1) {
                        await this.facilitateCollaboration(initialResponses, sanitizedMessage);
                    }

                    // Phase 3: Generate final consensus
                    if (document.getElementById('consensus').checked && initialResponses.length > 0) {
                        await this.generateFinalConsensus(initialResponses, sanitizedMessage);
                    }

                } catch (error) {
                    this.showError(`Orchestration failed: ${error.message}`);
                } finally {
                    this.isProcessing = false;
                    this.setLoadingState(false);
                }
            }

            sanitizeInput(input) {
                // Remove potentially dangerous HTML/script tags
                return input.replace(/<[^>]*>/g, '').trim();
            }

            async getInitialResponses(message, selectedModels) {
                const responses = [];
                const promises = selectedModels.map(async (modelId) => {
                    try {
                        this.updateModelStatus(modelId, 'busy');
                        const response = await this.queryAI(modelId, message);
                        this.updateModelStatus(modelId, 'ready');
                        
                        responses.push({
                            model: modelId,
                            content: response,
                            timestamp: Date.now()
                        });
                        
                        this.addAIResponse(modelId, response);
                        return response;
                    } catch (error) {
                        this.updateModelStatus(modelId, 'error');
                        this.showError(`${this.aiModels[modelId].name} failed: ${error.message}`);
                        return null;
                    }
                });

                await Promise.all(promises);
                return responses.filter(r => r !== null);
            }

            async queryAI(modelId, message) {
                const model = this.aiModels[modelId];
                if (!model) {
                    throw new Error(`Unknown model: ${modelId}`);
                }

                // Check if API key is available
                const apiKey = this.getAPIKeyForModel(modelId);
                if (!apiKey) {
                    // Fallback to demo mode
                    return this.generateDemoResponse(modelId, message);
                }

                // Rate limiting
                if (!this.canMakeRequest(modelId)) {
                    throw new Error('Rate limit exceeded. Please wait before making another request.');
                }

                try {
                    const response = await this.makeAPIRequest(modelId, message, apiKey);
                    this.updateRateLimiter(modelId);
                    return response;
                } catch (error) {
                    console.error(`API request failed for ${modelId}:`, error);
                    // Fallback to demo mode
                    return this.generateDemoResponse(modelId, message);
                }
            }

            getAPIKeyForModel(modelId) {
                const keyMap = {
                    gpt4: 'openai',
                    claude: 'anthropic',
                    gemini: 'google',
                    mistral: 'openai' // Mistral uses OpenAI-compatible API
                };
                
                const keyType = keyMap[modelId];
                return this.apiKeys[keyType];
            }

            canMakeRequest(modelId) {
                if (!this.rateLimiters.has(modelId)) {
                    this.rateLimiters.set(modelId, { lastRequest: 0, count: 0 });
                }
                
                const limiter = this.rateLimiters.get(modelId);
                const now = Date.now();
                const timeSinceLastRequest = now - limiter.lastRequest;
                
                // Rate limit: max 10 requests per minute per model
                if (timeSinceLastRequest < 6000) { // 6 seconds between requests
                    return false;
                }
                
                return true;
            }

            updateRateLimiter(modelId) {
                const limiter = this.rateLimiters.get(modelId);
                limiter.lastRequest = Date.now();
                limiter.count++;
            }

            async makeAPIRequest(modelId, message, apiKey) {
                const model = this.aiModels[modelId];
                
                const headers = {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                };

                let requestBody;
                let endpoint = model.endpoint;
                
                switch (modelId) {
                    case 'gpt4':
                        requestBody = {
                            model: 'gpt-4-turbo-preview',
                            messages: [{ role: 'user', content: message }],
                            max_tokens: 1000,
                            temperature: 0.7
                        };
                        break;
                        
                    case 'claude':
                        requestBody = {
                            model: 'claude-3-sonnet-20240229',
                            max_tokens: 1000,
                            messages: [{ role: 'user', content: message }]
                        };
                        break;
                        
                    case 'gemini':
                        headers['Authorization'] = `Bearer ${apiKey}`;
                        requestBody = {
                            contents: [{
                                parts: [{ text: message }]
                            }],
                            generationConfig: {
                                maxOutputTokens: 1000,
                                temperature: 0.7
                            }
                        };
                        break;
                        
                    case 'mistral':
                        requestBody = {
                            model: 'mistral-large-latest',
                            messages: [{ role: 'user', content: message }],
                            max_tokens: 1000,
                            temperature: 0.7
                        };
                        break;
                        
                    default:
                        throw new Error(`Unsupported model: ${modelId}`);
                }

                try {
                    const response = await fetch(endpoint, {
                        method: 'POST',
                        headers,
                        body: JSON.stringify(requestBody)
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`API request failed: ${response.status} ${response.statusText} - ${errorText}`);
                    }

                    const data = await response.json();
                    return this.extractResponseText(data, modelId);
                } catch (error) {
                    console.error(`API request failed for ${modelId}:`, error);
                    throw new Error(`Failed to get response from ${model.name}: ${error.message}`);
                }
            }

            extractResponseText(data, modelId) {
                try {
                    switch (modelId) {
                        case 'gpt4':
                            return data.choices?.[0]?.message?.content || 'No response generated';
                        case 'claude':
                            return data.content?.[0]?.text || 'No response generated';
                        case 'gemini':
                            return data.candidates?.[0]?.content?.parts?.[0]?.text || 'No response generated';
                        case 'mistral':
                            return data.choices?.[0]?.message?.content || 'No response generated';
                        default:
                            return 'Response format not supported';
                    }
                } catch (error) {
                    console.error('Error extracting response:', error);
                    return 'Error processing response';
                }
            }

            generateDemoResponse(modelId, message) {
                const lowerMessage = message.toLowerCase();
                const topic = this.extractTopic(lowerMessage);
                const model = this.aiModels[modelId];
                
                // Generate truly dynamic response based on message content
                const dynamicResponse = this.generateDynamicResponse(modelId, message, lowerMessage, topic);
                
                return `${model.name} Analysis (Demo Mode):\n\n${dynamicResponse}`;
            }

            generateDynamicResponse(modelId, message, lowerMessage, topic) {
                // Extract key words from the message
                const words = message.split(' ').filter(word => word.length > 3);
                const uniqueWords = [...new Set(words)];
                
                // Generate response based on model personality and message content
                switch(modelId) {
                    case 'gpt4':
                        return this.generateGPT4Response(message, lowerMessage, topic, uniqueWords);
                    case 'claude':
                        return this.generateClaudeResponse(message, lowerMessage, topic, uniqueWords);
                    case 'gemini':
                        return this.generateGeminiResponse(message, lowerMessage, topic, uniqueWords);
                    case 'mistral':
                        return this.generateMistralResponse(message, lowerMessage, topic, uniqueWords);
                    default:
                        return this.generateGPT4Response(message, lowerMessage, topic, uniqueWords);
                }
            }

            generateGPT4Response(message, lowerMessage, topic, uniqueWords) {
                const timestamp = Date.now();
                const randomFactor = timestamp % 100;
                
                if (lowerMessage.includes('marketing') || lowerMessage.includes('strategy') || lowerMessage.includes('business')) {
                    const strategies = [
                        `Based on your request about "${message}", here's a comprehensive marketing strategy:\n\n1. **Market Analysis**: Deep dive into target demographics and competitor landscape\n2. **Brand Positioning**: Develop unique value proposition based on "${uniqueWords.slice(0, 3).join(', ')}"\n3. **Channel Strategy**: Multi-platform approach with 40% digital, 30% content, 20% partnerships, 10% events\n4. **Success Metrics**: Track KPIs including conversion rates and customer lifetime value\n5. **Implementation Timeline**: 90-day rollout with monthly reviews`,
                        
                        `Strategic marketing approach for "${message}":\n\n**Phase 1: Research & Analysis**\n- Customer persona development\n- Competitive intelligence gathering\n- Market opportunity identification\n\n**Phase 2: Strategy Development**\n- Positioning statement creation\n- Channel mix optimization\n- Budget allocation strategy\n\n**Phase 3: Execution**\n- Campaign development and testing\n- Performance monitoring\n- Optimization based on data`,
                        
                        `Marketing strategy framework for your needs:\n\n**Target Audience**: ${uniqueWords.length > 0 ? uniqueWords[0] : 'Primary'} market focus\n**Value Proposition**: Differentiated approach based on market gaps\n**Distribution Channels**: Omnichannel presence with digital-first strategy\n**Budget Allocation**: Data-driven spending with ROI tracking\n**Success Metrics**: Conversion optimization and brand awareness`
                    ];
                    return strategies[randomFactor % strategies.length];
                }
                
                if (lowerMessage.includes('technical') || lowerMessage.includes('development') || lowerMessage.includes('code')) {
                    const techStrategies = [
                        `Technical implementation for "${message}":\n\n1. **Architecture Design**: Microservices with API-first approach\n2. **Technology Stack**: Modern cloud-native solutions (React, Node.js, AWS)\n3. **Security Framework**: OWASP compliance with regular security audits\n4. **Performance Optimization**: Caching strategies and CDN implementation\n5. **Deployment Pipeline**: CI/CD with automated testing and monitoring`,
                        
                        `Development strategy for your project:\n\n**System Architecture**:\n- Scalable microservices design\n- Load balancing and auto-scaling\n- Database optimization and caching\n\n**Development Process**:\n- Agile methodology with 2-week sprints\n- Code review and pair programming\n- Automated testing and deployment\n\n**Quality Assurance**:\n- Unit and integration testing\n- Performance monitoring\n- Security scanning and compliance`,
                        
                        `Technical approach for "${message}":\n\n**Infrastructure**: Cloud-native with containerization\n**Frontend**: Modern JavaScript framework with responsive design\n**Backend**: RESTful APIs with GraphQL support\n**Database**: Scalable NoSQL solution with caching\n**DevOps**: Automated deployment with monitoring and alerting`
                    ];
                    return techStrategies[randomFactor % techStrategies.length];
                }
                
                if (lowerMessage.includes('creative') || lowerMessage.includes('design') || lowerMessage.includes('content')) {
                    const creativeStrategies = [
                        `Creative strategy for "${message}":\n\n1. **Brand Identity**: Cohesive visual language and messaging framework\n2. **Content Strategy**: Multi-format content with storytelling approach\n3. **Design System**: Consistent UI/UX patterns and accessibility standards\n4. **Engagement Strategy**: Interactive elements and community building\n5. **Performance Tracking**: Creative metrics and user engagement analysis`,
                        
                        `Creative direction framework:\n\n**Brand Development**:\n- Visual identity and brand guidelines\n- Tone of voice and messaging strategy\n- Target audience persona development\n\n**Content Creation**:\n- Editorial calendar and content themes\n- Multi-platform content adaptation\n- User-generated content campaigns\n\n**Design Implementation**:\n- Responsive design principles\n- Accessibility compliance\n- Cross-platform consistency`,
                        
                        `Creative approach for "${message}":\n\n**Visual Design**: Modern, clean aesthetic with brand consistency\n**Content Strategy**: Educational and entertaining content mix\n**User Experience**: Intuitive navigation and engagement features\n**Brand Positioning**: Unique market differentiation\n**Community Building**: Interactive features and social engagement`
                    ];
                    return creativeStrategies[randomFactor % creativeStrategies.length];
                }
                
                // Generic response for other topics
                const genericResponses = [
                    `Comprehensive analysis of "${message}":\n\n1. **Problem Identification**: Key challenges and opportunities\n2. **Strategic Framework**: Systematic approach to solution development\n3. **Implementation Plan**: Step-by-step execution strategy\n4. **Success Metrics**: Measurable outcomes and KPIs\n5. **Risk Management**: Contingency planning and mitigation strategies`,
                    
                    `Strategic approach for "${message}":\n\n**Analysis Phase**:\n- Market research and competitive analysis\n- Stakeholder identification and requirements gathering\n- Risk assessment and opportunity evaluation\n\n**Strategy Development**:\n- Goal setting and objective definition\n- Resource allocation and timeline planning\n- Performance measurement framework\n\n**Execution Plan**:\n- Implementation roadmap with milestones\n- Team structure and responsibility matrix\n- Communication and change management strategy`,
                    
                    `Framework for addressing "${message}":\n\n**Research & Analysis**: Data-driven insights and market understanding\n**Strategy Formulation**: Evidence-based approach with clear objectives\n**Implementation**: Structured execution with quality assurance\n**Monitoring**: Continuous evaluation and optimization\n**Success Measurement**: ROI tracking and performance analytics`
                ];
                
                return genericResponses[randomFactor % genericResponses.length];
            }

            generateClaudeResponse(message, lowerMessage, topic, uniqueWords) {
                const timestamp = Date.now();
                const randomFactor = timestamp % 100;
                
                if (lowerMessage.includes('marketing') || lowerMessage.includes('strategy') || lowerMessage.includes('business')) {
                    const strategies = [
                        `From an analytical perspective on "${message}":\n\n**Market Research Phase**:\n- Customer interviews and survey methodology\n- Competitor analysis matrix with SWOT framework\n- Market gap identification and opportunity assessment\n\n**Strategy Development**:\n- Positioning statement refinement and testing\n- Channel effectiveness analysis with ROI modeling\n- Budget optimization using data-driven allocation\n\n**Implementation Plan**:\n- Timeline with critical path milestones\n- Resource allocation and capacity planning\n- Risk mitigation strategies and contingency plans`,
                        
                        `Analytical framework for "${message}":\n\n**Research Methodology**:\n- Quantitative and qualitative data collection\n- Statistical analysis and trend identification\n- Predictive modeling and scenario planning\n\n**Strategic Planning**:\n- Evidence-based decision making\n- Performance benchmarking and best practices\n- Continuous improvement and optimization\n\n**Execution Strategy**:\n- Phased rollout with pilot testing\n- Stakeholder engagement and change management\n- Performance monitoring and feedback loops`,
                        
                        `Strategic analysis for "${message}":\n\n**Data-Driven Approach**:\n- Market research and customer insights\n- Competitive intelligence and benchmarking\n- Performance analytics and optimization\n\n**Strategic Framework**:\n- Goal alignment and objective setting\n- Resource planning and allocation\n- Risk assessment and mitigation\n\n**Implementation Excellence**:\n- Process optimization and efficiency\n- Quality assurance and continuous improvement\n- Success measurement and reporting`
                    ];
                    return strategies[randomFactor % strategies.length];
                }
                
                if (lowerMessage.includes('technical') || lowerMessage.includes('development') || lowerMessage.includes('code')) {
                    const techStrategies = [
                        `System architecture considerations for "${message}":\n\n**Scalability**: Horizontal scaling with load balancing and auto-scaling\n**Reliability**: Fault tolerance with redundancy and failover mechanisms\n**Maintainability**: Clean code architecture with comprehensive documentation\n**Security**: OWASP compliance with regular security audits and penetration testing\n**Performance**: Caching strategies with CDN and database optimization`,
                        
                        `Technical architecture for "${message}":\n\n**System Design**:\n- Microservices architecture with API gateway\n- Event-driven architecture for scalability\n- Database design with optimization strategies\n\n**Development Standards**:\n- Code quality and review processes\n- Testing strategies and automation\n- Documentation and knowledge management\n\n**Operational Excellence**:\n- Monitoring and alerting systems\n- Incident response and disaster recovery\n- Performance optimization and tuning`,
                        
                        `Engineering approach for "${message}":\n\n**Architecture Principles**:\n- Scalable and maintainable design\n- Security-first development practices\n- Performance optimization and monitoring\n\n**Development Process**:\n- Agile methodology with continuous integration\n- Code review and quality assurance\n- Automated testing and deployment\n\n**Operational Excellence**:\n- Monitoring and observability\n- Incident management and response\n- Continuous improvement and optimization`
                    ];
                    return techStrategies[randomFactor % techStrategies.length];
                }
                
                if (lowerMessage.includes('creative') || lowerMessage.includes('design') || lowerMessage.includes('content')) {
                    const creativeStrategies = [
                        `Creative strategy framework for "${message}":\n\n**Brand Positioning**:\n- Core values and personality development\n- Target audience persona creation\n- Competitive differentiation strategy\n\n**Content Strategy**:\n- Educational and entertaining content balance\n- User-generated content campaigns and engagement\n- Influencer partnerships and collaboration\n\n**Visual Identity**:\n- Consistent design system and guidelines\n- Accessibility compliance and inclusive design\n- Cross-platform adaptation and optimization`,
                        
                        `Creative direction for "${message}":\n\n**Brand Development**:\n- Visual identity and brand guidelines\n- Tone of voice and messaging strategy\n- Target audience understanding and engagement\n\n**Content Creation**:\n- Editorial calendar and content themes\n- Multi-platform content adaptation\n- Community building and user engagement\n\n**Design Implementation**:\n- Responsive design principles\n- Accessibility and usability standards\n- Cross-platform consistency and optimization`,
                        
                        `Creative approach for "${message}":\n\n**Brand Strategy**:\n- Visual identity and brand positioning\n- Target audience and market research\n- Competitive analysis and differentiation\n\n**Content Development**:\n- Editorial strategy and content planning\n- Multi-format content creation\n- Community engagement and user interaction\n\n**Design Excellence**:\n- User experience and interface design\n- Accessibility and inclusive design\n- Cross-platform consistency and optimization`
                    ];
                    return creativeStrategies[randomFactor % creativeStrategies.length];
                }
                
                // Generic analytical response
                const genericResponses = [
                    `Analytical framework for "${message}":\n\n**Research & Analysis**:\n- Data collection and analysis methodology\n- Market research and competitive intelligence\n- Stakeholder analysis and requirements gathering\n\n**Strategic Planning**:\n- Goal setting and objective definition\n- Resource allocation and capacity planning\n- Risk assessment and mitigation strategies\n\n**Implementation Excellence**:\n- Process optimization and efficiency\n- Quality assurance and continuous improvement\n- Performance measurement and reporting`,
                    
                    `Strategic analysis for "${message}":\n\n**Comprehensive Research**:\n- Market analysis and trend identification\n- Competitive benchmarking and best practices\n- Customer insights and behavior analysis\n\n**Strategic Framework**:\n- Evidence-based decision making\n- Performance optimization and efficiency\n- Continuous improvement and innovation\n\n**Execution Excellence**:\n- Phased implementation with pilot testing\n- Stakeholder engagement and change management\n- Success measurement and ROI tracking`,
                    
                    `Analytical approach for "${message}":\n\n**Data-Driven Insights**:\n- Market research and competitive analysis\n- Customer behavior and preference analysis\n- Performance benchmarking and optimization\n\n**Strategic Planning**:\n- Goal alignment and objective setting\n- Resource planning and allocation\n- Risk assessment and mitigation\n\n**Implementation Strategy**:\n- Process optimization and efficiency\n- Quality assurance and continuous improvement\n- Success measurement and reporting`
                ];
                
                return genericResponses[randomFactor % genericResponses.length];
            }

            generateGeminiResponse(message, lowerMessage, topic, uniqueWords) {
                const timestamp = Date.now();
                const randomFactor = timestamp % 100;
                
                if (lowerMessage.includes('marketing') || lowerMessage.includes('strategy') || lowerMessage.includes('business')) {
                    const strategies = [
                        `Multimodal marketing approach for "${message}":\n\n**Digital Presence**:\n- Website optimization with SEO and performance\n- Social media strategy across multiple platforms\n- Email marketing automation and personalization\n\n**Content Marketing**:\n- Blog and thought leadership content\n- Video content and webinar strategy\n- Podcast and audio content development\n\n**Data-Driven Decisions**:\n- Analytics and tracking setup\n- A/B testing framework and optimization\n- Customer journey mapping and touchpoint optimization`,
                        
                        `Digital-first strategy for "${message}":\n\n**Online Presence**:\n- Website design and user experience\n- Social media engagement and community building\n- Email marketing and automation\n\n**Content Strategy**:\n- Educational and entertaining content mix\n- Video and multimedia content creation\n- Influencer partnerships and collaborations\n\n**Performance Optimization**:\n- Analytics and data tracking\n- Conversion optimization and testing\n- Customer experience and journey mapping`,
                        
                        `Modern marketing approach for "${message}":\n\n**Digital Strategy**:\n- Website optimization and SEO\n- Social media presence and engagement\n- Email marketing and automation\n\n**Content Development**:\n- Blog and educational content\n- Video and multimedia creation\n- Influencer and partnership strategy\n\n**Data Analytics**:\n- Performance tracking and measurement\n- A/B testing and optimization\n- Customer journey and experience mapping`
                    ];
                    return strategies[randomFactor % strategies.length];
                }
                
                if (lowerMessage.includes('technical') || lowerMessage.includes('development') || lowerMessage.includes('code')) {
                    const techStrategies = [
                        `Modern development approach for "${message}":\n\n**Agile Methodology**:\n- Sprint planning and retrospectives\n- Continuous integration and deployment\n- Automated testing and quality assurance\n\n**Cloud Infrastructure**:\n- Multi-cloud strategy and optimization\n- Container orchestration and management\n- Serverless functions and microservices\n\n**Quality Assurance**:\n- Code review process and standards\n- Performance monitoring and optimization\n- Security scanning and compliance`,
                        
                        `Contemporary development for "${message}":\n\n**Development Process**:\n- Agile methodology with continuous delivery\n- Code review and quality assurance\n- Automated testing and deployment\n\n**Infrastructure**:\n- Cloud-native architecture and design\n- Containerization and orchestration\n- Serverless and microservices approach\n\n**Quality Excellence**:\n- Performance monitoring and optimization\n- Security scanning and compliance\n- Continuous improvement and innovation`,
                        
                        `Modern engineering for "${message}":\n\n**Development Excellence**:\n- Agile methodology and continuous delivery\n- Code review and quality assurance\n- Automated testing and deployment\n\n**Infrastructure Strategy**:\n- Cloud-native architecture and design\n- Containerization and orchestration\n- Serverless and microservices approach\n\n**Quality Assurance**:\n- Performance monitoring and optimization\n- Security scanning and compliance\n- Continuous improvement and innovation`
                    ];
                    return techStrategies[randomFactor % techStrategies.length];
                }
                
                if (lowerMessage.includes('creative') || lowerMessage.includes('design') || lowerMessage.includes('content')) {
                    const creativeStrategies = [
                        `Creative digital strategy for "${message}":\n\n**Visual Design**:\n- Modern, clean aesthetic with brand consistency\n- Responsive design and mobile optimization\n- Accessibility compliance and inclusive design\n\n**Content Strategy**:\n- Educational and entertaining content mix\n- Video and multimedia content creation\n- User-generated content and community engagement\n\n**User Experience**:\n- Intuitive navigation and interaction design\n- Cross-platform consistency and optimization\n- Performance and loading speed optimization`,
                        
                        `Digital creative approach for "${message}":\n\n**Design Excellence**:\n- Modern visual design and branding\n- Responsive and accessible design\n- Cross-platform consistency and optimization\n\n**Content Development**:\n- Educational and entertaining content\n- Video and multimedia creation\n- Community engagement and user interaction\n\n**User Experience**:\n- Intuitive navigation and interaction\n- Performance optimization and speed\n- Accessibility and inclusive design`,
                        
                        `Creative digital strategy for "${message}":\n\n**Visual Design**:\n- Modern aesthetic with brand consistency\n- Responsive design and mobile optimization\n- Accessibility and inclusive design\n\n**Content Strategy**:\n- Educational and entertaining content\n- Video and multimedia creation\n- Community engagement and interaction\n\n**User Experience**:\n- Intuitive navigation and design\n- Cross-platform consistency\n- Performance and accessibility optimization`
                    ];
                    return creativeStrategies[randomFactor % creativeStrategies.length];
                }
                
                // Generic digital response
                const genericResponses = [
                    `Digital-first approach for "${message}":\n\n**Online Strategy**:\n- Website optimization and user experience\n- Social media presence and engagement\n- Email marketing and automation\n\n**Content Development**:\n- Educational and entertaining content\n- Video and multimedia creation\n- Community building and engagement\n\n**Performance Optimization**:\n- Analytics and data tracking\n- A/B testing and conversion optimization\n- Customer journey and experience mapping`,
                    
                    `Modern digital strategy for "${message}":\n\n**Digital Presence**:\n- Website design and optimization\n- Social media strategy and engagement\n- Email marketing and automation\n\n**Content Strategy**:\n- Educational and entertaining content\n- Video and multimedia creation\n- Community engagement and interaction\n\n**Performance Excellence**:\n- Analytics and measurement\n- Conversion optimization and testing\n- Customer experience and journey mapping`,
                    
                    `Contemporary digital approach for "${message}":\n\n**Online Strategy**:\n- Website optimization and user experience\n- Social media presence and engagement\n- Email marketing and automation\n\n**Content Development**:\n- Educational and entertaining content\n- Video and multimedia creation\n- Community building and engagement\n\n**Performance Optimization**:\n- Analytics and data tracking\n- A/B testing and conversion optimization\n- Customer journey and experience mapping`
                ];
                
                return genericResponses[randomFactor % genericResponses.length];
            }

            generateMistralResponse(message, lowerMessage, topic, uniqueWords) {
                const timestamp = Date.now();
                const randomFactor = timestamp % 100;
                
                if (lowerMessage.includes('marketing') || lowerMessage.includes('strategy') || lowerMessage.includes('business')) {
                    const strategies = [
                        `Efficient marketing strategy for "${message}":\n\n**Quick Wins**:\n- Social media optimization and engagement\n- Local SEO and directory listings\n- Referral programs and partnerships\n\n**Sustainable Growth**:\n- Content marketing funnel development\n- Email list building and nurturing\n- Community engagement and loyalty\n\n**Measurement**:\n- ROI tracking for each channel\n- Customer lifetime value optimization\n- Conversion rate optimization and testing`,
                        
                        `Lean marketing approach for "${message}":\n\n**Immediate Impact**:\n- Social media optimization and engagement\n- Local SEO and directory presence\n- Referral and partnership programs\n\n**Long-term Strategy**:\n- Content marketing and lead generation\n- Email list building and automation\n- Community building and engagement\n\n**Performance Tracking**:\n- ROI measurement and optimization\n- Customer lifetime value analysis\n- Conversion optimization and testing`,
                        
                        `Efficient marketing for "${message}":\n\n**Quick Results**:\n- Social media optimization and engagement\n- Local SEO and directory presence\n- Referral and partnership programs\n\n**Sustainable Growth**:\n- Content marketing and lead generation\n- Email list building and nurturing\n- Community engagement and loyalty\n\n**Performance Measurement**:\n- ROI tracking and optimization\n- Customer lifetime value analysis\n- Conversion rate optimization`
                    ];
                    return strategies[randomFactor % strategies.length];
                }
                
                if (lowerMessage.includes('technical') || lowerMessage.includes('development') || lowerMessage.includes('code')) {
                    const techStrategies = [
                        `Lean technical approach for "${message}":\n\n**MVP Development**:\n- Core features first with rapid iteration\n- User feedback integration and testing\n- Iterative improvements and optimization\n\n**Cost Optimization**:\n- Cloud cost management and optimization\n- Open-source solutions and alternatives\n- Efficient resource usage and scaling\n\n**Quality Focus**:\n- Automated testing and quality assurance\n- Code quality metrics and standards\n- Security best practices and compliance`,
                        
                        `Efficient development for "${message}":\n\n**MVP Strategy**:\n- Core features with rapid development\n- User feedback and iterative improvement\n- Continuous optimization and refinement\n\n**Cost Management**:\n- Cloud cost optimization and efficiency\n- Open-source solutions and alternatives\n- Resource optimization and scaling\n\n**Quality Excellence**:\n- Automated testing and quality assurance\n- Code quality and performance metrics\n- Security best practices and compliance`,
                        
                        `Lean engineering for "${message}":\n\n**MVP Development**:\n- Core features with rapid iteration\n- User feedback and continuous improvement\n- Iterative optimization and refinement\n\n**Cost Optimization**:\n- Cloud cost management and efficiency\n- Open-source solutions and alternatives\n- Resource optimization and scaling\n\n**Quality Focus**:\n- Automated testing and quality assurance\n- Code quality and performance metrics\n- Security best practices and compliance`
                    ];
                    return techStrategies[randomFactor % techStrategies.length];
                }
                
                if (lowerMessage.includes('creative') || lowerMessage.includes('design') || lowerMessage.includes('content')) {
                    const creativeStrategies = [
                        `Efficient creative strategy for "${message}":\n\n**Quick Wins**:\n- Social media content optimization\n- Local design and branding presence\n- Referral and partnership content\n\n**Sustainable Growth**:\n- Content marketing and brand building\n- Email content and nurturing\n- Community engagement and loyalty\n\n**Performance Measurement**:\n- Content ROI tracking and optimization\n- Brand engagement and loyalty metrics\n- Conversion optimization and testing`,
                        
                        `Lean creative approach for "${message}":\n\n**Immediate Impact**:\n- Social media content and engagement\n- Local design and branding presence\n- Referral and partnership content\n\n**Long-term Strategy**:\n- Content marketing and brand building\n- Email content and nurturing\n- Community engagement and loyalty\n\n**Performance Tracking**:\n- Content ROI and engagement metrics\n- Brand loyalty and conversion optimization\n- Continuous improvement and testing`,
                        
                        `Efficient creative for "${message}":\n\n**Quick Results**:\n- Social media content optimization\n- Local design and branding presence\n- Referral and partnership content\n\n**Sustainable Growth**:\n- Content marketing and brand building\n- Email content and nurturing\n- Community engagement and loyalty\n\n**Performance Measurement**:\n- Content ROI and engagement tracking\n- Brand loyalty and conversion optimization\n- Continuous improvement and testing`
                    ];
                    return creativeStrategies[randomFactor % creativeStrategies.length];
                }
                
                // Generic efficient response
                const genericResponses = [
                    `Efficient approach for "${message}":\n\n**Quick Wins**:\n- Immediate impact strategies and tactics\n- Low-cost, high-impact initiatives\n- Rapid implementation and testing\n\n**Sustainable Growth**:\n- Long-term strategy development\n- Resource optimization and efficiency\n- Continuous improvement and innovation\n\n**Performance Measurement**:\n- ROI tracking and optimization\n- Performance metrics and analytics\n- Continuous improvement and testing`,
                    
                    `Lean strategy for "${message}":\n\n**Immediate Impact**:\n- Quick wins and rapid implementation\n- Low-cost, high-impact initiatives\n- Fast testing and optimization\n\n**Long-term Strategy**:\n- Sustainable growth and development\n- Resource optimization and efficiency\n- Continuous improvement and innovation\n\n**Performance Tracking**:\n- ROI measurement and optimization\n- Performance metrics and analytics\n- Continuous improvement and testing`,
                    
                    `Efficient strategy for "${message}":\n\n**Quick Results**:\n- Immediate impact and rapid implementation\n- Low-cost, high-impact initiatives\n- Fast testing and optimization\n\n**Sustainable Growth**:\n- Long-term strategy and development\n- Resource optimization and efficiency\n- Continuous improvement and innovation\n\n**Performance Measurement**:\n- ROI tracking and optimization\n- Performance metrics and analytics\n- Continuous improvement and testing`
                ];
                
                return genericResponses[randomFactor % genericResponses.length];
            }

            async facilitateCollaboration(responses, originalMessage) {
                if (responses.length < 2) return;

                this.addCollaborationMessage('🤝 AI Models are now collaborating to refine the results...');

                // Create a collaborative prompt
                const collaborationPrompt = this.createCollaborationPrompt(responses, originalMessage);
                
                // Have each AI review and improve based on others' responses
                for (const response of responses) {
                    try {
                        const improvedResponse = await this.queryAI(
                            response.model, 
                            `Review and improve this response based on the collaborative context:\n\n${collaborationPrompt}\n\nYour original response: ${response.content}\n\nProvide an improved version:`
                        );
                        
                        this.addAIResponse(response.model, improvedResponse, true);
                    } catch (error) {
                        console.error(`Collaboration failed for ${response.model}:`, error);
                    }
                }
            }

            async generateFinalConsensus(responses, originalMessage) {
                if (responses.length === 0) return;

                this.addCollaborationMessage('🎯 Generating final consensus from all AI responses...');

                const consensusPrompt = this.createConsensusPrompt(responses, originalMessage);
                
                try {
                    // Use GPT-4 for final consensus (or the first available model)
                    const consensusModel = responses.find(r => r.model === 'gpt4')?.model || responses[0].model;
                    const finalConsensus = await this.queryAI(consensusModel, consensusPrompt);
                    
                    this.addFinalResult(finalConsensus);
                } catch (error) {
                    this.showError(`Failed to generate consensus: ${error.message}`);
                }
            }

            createCollaborationPrompt(responses, originalMessage) {
                const responsesText = responses.map(r => 
                    `${this.aiModels[r.model].name}:\n${r.content}`
                ).join('\n\n');
                
                return `Original Request: ${originalMessage}\n\nResponses from other AI models:\n\n${responsesText}\n\nPlease review these responses and provide an improved version that incorporates the best insights from all models.`;
            }

            createConsensusPrompt(responses, originalMessage) {
                const responsesText = responses.map(r => 
                    `${this.aiModels[r.model].name}:\n${r.content}`
                ).join('\n\n');
                
                return `Original Request: ${originalMessage}\n\nAll AI Responses:\n\n${responsesText}\n\nPlease provide a comprehensive final consensus that:\n1. Synthesizes the best insights from all responses\n2. Resolves any contradictions\n3. Provides actionable recommendations\n4. Is well-structured and easy to understand`;
            }

            extractTopic(message) {
                if (message.includes('marketing') || message.includes('strategy') || message.includes('business')) return 'marketing';
                if (message.includes('technical') || message.includes('development') || message.includes('code')) return 'technical';
                if (message.includes('creative') || message.includes('design') || message.includes('content')) return 'creative';
                return 'marketing';
            }

            addMessage(type, content) {
                const messagesContainer = document.getElementById('messages');
                const messageDiv = document.createElement('div');
                messageDiv.className = 'message';

                if (type === 'user') {
                    messageDiv.innerHTML = `<div class="user-message">${this.escapeHtml(content)}</div>`;
                }

                messagesContainer.appendChild(messageDiv);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }

            addAIResponse(modelId, content, isCollaboration = false) {
                const messagesContainer = document.getElementById('messages');
                const messageDiv = document.createElement('div');
                messageDiv.className = 'message';

                const model = this.aiModels[modelId];
                const collaborationText = isCollaboration ? ' (Collaborative Refinement)' : '';

                messageDiv.innerHTML = `
                    <div class="ai-response">
                        <div class="ai-response-header">
                            <div class="ai-avatar" style="background: ${model.color};">${model.avatar}</div>
                            <div class="ai-name">${this.escapeHtml(model.name)}${collaborationText}</div>
                        </div>
                        <div class="ai-response-content">${this.formatResponse(content)}</div>
                    </div>
                `;

                messagesContainer.appendChild(messageDiv);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }

            addCollaborationMessage(content) {
                const messagesContainer = document.getElementById('messages');
                const messageDiv = document.createElement('div');
                messageDiv.className = 'message';

                messageDiv.innerHTML = `
                    <div class="collaboration-indicator">
                        ${this.escapeHtml(content)}
                    </div>
                `;

                messagesContainer.appendChild(messageDiv);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }

            addFinalResult(content) {
                const messagesContainer = document.getElementById('messages');
                const messageDiv = document.createElement('div');
                messageDiv.className = 'message';

                messageDiv.innerHTML = `
                    <div class="final-result">
                        <h4>🎯 Final Consensus</h4>
                        <div class="ai-response-content">${this.formatResponse(content)}</div>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: 100%;"></div>
                        </div>
                    </div>
                `;

                messagesContainer.appendChild(messageDiv);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            formatResponse(content) {
                // Convert markdown-style formatting to HTML
                return content
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/\*(.*?)\*/g, '<em>$1</em>')
                    .replace(/\n/g, '<br>')
                    .replace(/^(\d+\.\s)/gm, '<br><strong>$1</strong>');
            }

            updateModelStatus(modelId, status) {
                const modelElement = document.querySelector(`[data-model="${modelId}"]`);
                if (modelElement) {
                    const statusElement = modelElement.querySelector('.ai-status');
                    statusElement.className = `ai-status ${status}`;
                }
            }

            setLoadingState(loading) {
                const sendButton = document.getElementById('sendButton');
                if (loading) {
                    sendButton.disabled = true;
                    sendButton.innerHTML = '<span class="loading"></span> Orchestrating...';
                } else {
                    sendButton.disabled = false;
                    sendButton.innerHTML = 'Orchestrate';
                }
            }

            showError(message) {
                const messagesContainer = document.getElementById('messages');
                const messageDiv = document.createElement('div');
                messageDiv.className = 'message';

                messageDiv.innerHTML = `
                    <div class="error-message">
                        ⚠️ ${this.escapeHtml(message)}
                    </div>
                `;

                messagesContainer.appendChild(messageDiv);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }

            saveAPIKeys() {
                const openaiKey = document.getElementById('openai-key').value.trim();
                const anthropicKey = document.getElementById('anthropic-key').value.trim();
                const googleKey = document.getElementById('google-key').value.trim();

                // Validate keys
                const errors = [];
                if (openaiKey && !this.isValidAPIKey(openaiKey, 'openai-key')) {
                    errors.push('Invalid OpenAI API key format');
                }
                if (anthropicKey && !this.isValidAPIKey(anthropicKey, 'anthropic-key')) {
                    errors.push('Invalid Anthropic API key format');
                }
                if (googleKey && !this.isValidAPIKey(googleKey, 'google-key')) {
                    errors.push('Invalid Google API key format');
                }

                if (errors.length > 0) {
                    this.showError(`API key validation failed: ${errors.join(', ')}`);
                    return;
                }

                this.apiKeys = {
                    openai: openaiKey,
                    anthropic: anthropicKey,
                    google: googleKey
                };

                // Encrypt keys before storing (basic encryption)
                const encryptedKeys = this.encryptKeys(this.apiKeys);
                localStorage.setItem('aiOrchestratorKeys', JSON.stringify(encryptedKeys));
                this.showSuccess('API keys saved securely!');
            }

            encryptKeys(keys) {
                // Basic encryption - in production, use a proper encryption library
                const salt = 'ai_orchestrator_salt_2024';
                const encrypted = {};
                
                for (const [key, value] of Object.entries(keys)) {
                    if (value) {
                        // Simple XOR encryption (not for production use)
                        encrypted[key] = btoa(value + salt);
                    }
                }
                
                return encrypted;
            }

            decryptKeys(encryptedKeys) {
                const decrypted = {};
                
                for (const [key, value] of Object.entries(encryptedKeys)) {
                    if (value) {
                        try {
                            const decoded = atob(value);
                            decrypted[key] = decoded.replace('ai_orchestrator_salt_2024', '');
                        } catch (error) {
                            console.error('Failed to decrypt key:', key);
                        }
                    }
                }
                
                return decrypted;
            }

            loadSavedKeys() {
                try {
                    const savedKeys = localStorage.getItem('aiOrchestratorKeys');
                    if (savedKeys) {
                        const encryptedKeys = JSON.parse(savedKeys);
                        this.apiKeys = this.decryptKeys(encryptedKeys);
                        
                        document.getElementById('openai-key').value = this.apiKeys.openai || '';
                        document.getElementById('anthropic-key').value = this.apiKeys.anthropic || '';
                        document.getElementById('google-key').value = this.apiKeys.google || '';
                    }
                } catch (error) {
                    console.error('Failed to load saved keys:', error);
                    // Clear corrupted data
                    localStorage.removeItem('aiOrchestratorKeys');
                }
            }

            showSuccess(message) {
                const messagesContainer = document.getElementById('messages');
                const messageDiv = document.createElement('div');
                messageDiv.className = 'message';

                messageDiv.innerHTML = `
                    <div class="success-message">
                        ✅ ${this.escapeHtml(message)}
                    </div>
                `;

                messagesContainer.appendChild(messageDiv);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }
        }

        // Initialize the orchestrator when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.aiOrchestrator = new AIOrchestrator();
        });
    </script>
</body>
</html> 
